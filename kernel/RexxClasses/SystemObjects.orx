/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 1995, 2004 IBM Corporation. All rights reserved.             */
/* Copyright (c) 2005-2006 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/******************************************************************************/
/* REXX Macros                                                  oryxs.cmd     */
/*                                                                            */
/* Create the Rexx system objects                                             */
/*                                                                            */
/******************************************************************************/

/* Create the Oryx System Objects */
/* check which system */
say 'System is' .system["NAME"] 'version' .system~version

.Monitor~!REXXDefined                  /* define this as "unchangeable"     */
.Set~define('PUT', .methods['PUT'])    /* add common methods to SET and BAG */
.Set~define('[]=', .methods['PUT'])
.Bag~define('PUT', .methods['PUT'])
.Bag~define('[]=', .methods['PUT'])
.Set~!REXXDefined
.Bag~!REXXDefined
.Alarm~!REXXDefined
.CircularQueue~!REXXDEfined
.Properties~!REXXDEfined

.environment~setentry('MONITOR', .Monitor)
.environment~setentry('SET', .Set)
.environment~setentry('BAG', .Bag)
.environment~setentry('CIRCULARQUEUE', .CircularQueue)
.environment~setentry('PROPERTIES', .Properties)

parse version a b c                    /* if no thread support, no alarm class */
if '6.00' <= b then
  .environment~setentry('ALARM', .Alarm)

call 'StreamClasses.orx'   /* MHES 29122004 - was oryxio.       */

say 'Stream methods setup'

/* Unattached methods used by SET and BAG */

/*****************************************/
/* PUT           method                  */
/*****************************************/
::METHOD put                           /* add an entry to the set           */
use strict arg index, value=(index)    /* get the index                     */

  if index \== value then              /* these must be identical           */
    raise syntax 93.949                /* this is an error                  */
  self~put:super(index, index)         /* add to the table                  */
  return


/* ******************************** */
/*    M O N I T O R    C L A S S    */
/* ******************************** */
 /**************************************************************************/
 /* The monitor class will keep track of a stack of destination objects    */
 /* with the last one being the active destination for message sends that  */
 /* are processed by the monitor unknown method.                           */
 /**************************************************************************/

::CLASS 'Monitor'

::METHOD init
 /**************************************************************************/
 /* Class  Monitor                                                         */
 /* Method INIT                                                            */
 /* Function                                                               */
 /*        To initialize the monitor object with a destination for any     */
 /*        non-monitor messages                                            */
 /* Input  Destination object                                              */
 /* Output Self (monitor object)                                           */
 /**************************************************************************/
 expose destination
 use strict arg dest = .nil
 destination = .queue~new
 if arg(1,'e') then
   destination~push(dest)
 return

::METHOD destination
 /**************************************************************************/
 /* Class  Monitor                                                         */
 /* Method DESTINATION                                                     */
 /* Function                                                               */
 /*        To stack a destination if one is passed as an argument.         */
 /*        To unstack a destination if no argument is passed in.           */
 /* Input  Destination object                                              */
 /* Output The destination object to be unstacked next after the current   */
 /*        message function is handled                                     */
 /**************************************************************************/
 expose destination
 use strict arg dest = .nil
 if arg(1,'e') then
   destination~push(dest)
 else
   destination~pull
 return destination~peek


::METHOD current
 /**************************************************************************/
 /* Class  Monitor                                                         */
 /* Method CURRENT                                                         */
 /* Function                                                               */
 /*        To return the active destination for this monitor object        */
 /* Input  None                                                            */
 /* Output Current destination object                                      */
 /**************************************************************************/
 expose destination
 use strict arg
 return destination~peek

::METHOD unknown unguarded
 /**************************************************************************/
 /* Class  Monitor                                                         */
 /* Method UNKNOWN                                                         */
 /* Function                                                               */
 /*        To forward any message sends that are not monitor messages      */
 /*        to the currently active destination                             */
 /* Input  Message name and Argument list                                  */
 /* Output Any return from the forwarded message                           */
 /**************************************************************************/
 /* unknown: forward monitored message to destination */
  expose destination
  use strict arg msgname, arglist

  forward to (destination~peek) message (msgname) arguments (arglist)


/* *************************************** */
/*    S E T                   C L A S S    */
/* *************************************** */

::CLASS 'Set' SUBCLASS table
/*****************************************/
/* OF         method                     */
/*****************************************/
::METHOD of CLASS
if (arg() < 1) then                    /* no index given?                   */
  raise syntax 93.901 array (1)        /* raise an error                    */
new = self~new                         /* create a new set                  */
do i = 1 to arg()                      /* loop through all the arguments    */
  if arg(i, 'O') then                  /* omitted argument?                 */
    raise syntax 93.903 array (i)      /* raise an error                    */
  new~put(arg(i))                      /* add this argument                 */
end
return new                             /* return new set                    */

/*****************************************/
/* XOR        method                     */
/*****************************************/
::METHOD xor                           /* take the exclusive or of a set    */
use strict arg other                   /* get the companion object          */

signal on nomethod

new = self~copy
do index over other                    /* loop over the other collection    */
  if self~hasindex(index) then         /* in this collection?               */
    new~remove(index)                  /* remove from the reference set     */
  else
    new~put(index)                     /* add non-located to target set     */
end
return new                             /* return the XOR collection         */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */

/*****************************************/
/* INTERSECTION  method                  */
/*****************************************/
::METHOD intersection                  /* take the intersection of sets     */
use strict arg other                   /* get the other collection          */

signal on nomethod
new = self~class~new                   /* create a new collection           */
do index over other                    /* loop over the other collection    */
  if self~hasindex(index) then         /* in this collection?               */
    new~put(index)                     /* add to the target collection      */
end
return new                             /* return the difference collection  */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */


/*****************************************/
/* UNION         method                  */
/*****************************************/
::METHOD union                         /* take the union of sets            */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy                        /* copy the collection               */
do index over other                    /* loop over the other collection    */
  if \new~hasindex(index) then         /* not already there?                */
    new~put(index)                     /* add to the target collection      */
end

return new                             /* return the target collection      */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */


/*****************************************/
/* SUBSET        method                  */
/*****************************************/
::METHOD subset                        /* do we have a subset?              */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

object = self~copy                     /* make a copy of this object        */
do index over other                    /* loop over the other collection    */
  object~remove(index)                 /* remove from the target collection */
end
return 0=object~items                  /* if nothing left -> proper subset  */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */


/*****************************************/
/* PUTALL        method                  */
/*****************************************/
::method putall
  use strict arg other

  supplier = other~supplier              /* get an other supplier             */
  do while supplier~available            /* loop over the other collection    */
    self~put(supplier~item)              -- set and bag only use the item, ignoring the index.
    supplier~next
  end


/* *************************************** */
/*    B A G                   C L A S S    */
/* *************************************** */

::CLASS 'Bag' SUBCLASS relation
::METHOD of CLASS
if (arg() < 1) then                    /* no index given?                   */
  raise syntax 93.901 array (1)        /* raise an error                    */

new = self~new                         /* create a new bag                  */
do i = 1 to arg()                      /* loop through all the arguments    */
  if arg(i, 'O') then                  /* omitted argument?                 */
    raise syntax 93.903 array (i)      /* raise an error                    */
  new~put(arg(i))                      /* add this argument                 */
end
return new                             /* return new bag                    */

/*****************************************/
/* UNION         method                  */
/*****************************************/
::METHOD union
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method requests      */

new = self~copy                        /* copy ourself                      */
do index over other                    /* loop over the other collection    */
  new~put(index)                       /* add to the target collection      */
end
return new                             /* return the union collection       */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */

/*****************************************/
/* XOR           method                  */
/*****************************************/
::METHOD xor
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy
catcher = self~class~new               /* create a new empty one            */
do index over other                    /* loop over the other collection    */
  if new~hasindex(index) then          /* in the reference collection?      */
    new~remove(index)                  /* remove from the reference set     */
  else
    catcher~put(index)                 /* add non-located to the catcher    */
end
return new~union(catcher)              /* now remerge these collections     */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */

/*****************************************/
/* INTERSECTION  method                  */
/*****************************************/
::METHOD intersection
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

new = self~class~new                   /* start with a new collection       */
object = self~copy                     /* copy the target collection        */
do index over other                    /* loop over the other collection    */
  if object~hasindex(index) then do    /* in the reference collection?      */
    new~put(index)                     /* add to the target collection      */
    object~remove(index)               /* remove from the reference set     */
  end
end
return new                             /* return the intersection collection*/

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */

/*****************************************/
/* DIFFERENCE method                     */
/*****************************************/
::METHOD difference
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy                        /* make a new set                    */
do index over other                    /* loop over the other collection    */
  new~remove(index)                    /* "subtract" this item              */
end
return new                             /* return the difference collection  */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */

/*****************************************/
/* SUBSET        method                  */
/*****************************************/
::METHOD subset
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

object = self~copy                     /* make a copy of this object        */
do index over other                    /* loop over the other collection    */
  object~remove(index)                 /* remove from the target collection */
end
return 0=object~items                  /* if nothing left -> proper subset  */

nomethod:                              /* unknown method sent               */
  raise syntax 93.948 array(1, "Collection") /* no, complain about it  */


/*****************************************/
/* PUTALL        method                  */
/*****************************************/
::method putall
  use strict arg other

  supplier = other~supplier              /* get an other supplier             */
  do while supplier~available            /* loop over the other collection    */
    self~put(supplier~item)              -- set and bag only use the item, ignoring the index.
    supplier~next
  end

/* ******************************** */
/*    A L A R M        C L A S S    */
/* ******************************** */
 /**************************************************************************/
 /* The Alarm class provides timing and notification capability by         */
 /* providing a facility to send any message to any object at a given      */
 /* time. A pending alram request can also be cancelled.                   */
 /**************************************************************************/

::CLASS 'Alarm' SUBCLASS object

::METHOD init
 /**************************************************************************/
 /* Class  Alarm                                                           */
 /* Method INIT                                                            */
 /* Function                                                               */
 /*        To set up an alarm for a future time 'atime'. At that time      */
 /*        the alarm object sends the message specified by the message     */
 /*        object 'message'.                                               */
 /* Input  atime - a string. Can be specified in 2 formats.                */
 /*        1. 'hh:mm:ss' - An absolute time. At the specified time         */
 /*            the alarm object send the message specified by the message  */
 /*            object.                                                     */
 /*        2. 'secs'     - number of seconds from the present time.        */
 /*        message - a message object                                      */
 /* Output Nothing                                                         */
 /**************************************************************************/

 expose timer canceled msgobj timerStarted eventSemHandle;
 timer = 0                             /* set up initial flag states        */
 eventSemHandle = 0
 timerStarted = 0
 canceled = .false

 use strict arg atime, msgobj          /* get the arguments                 */

                                       /* not a message object?             */
 if (msgobj~request('MESSAGE') = .nil) then
                                       /* have an error                     */
   raise syntax 93.948 array (2,'MESSAGE')

 if datatype(atime, 'W') then do       /* just a delta specification?       */
   if atime < 0 then                   /* got a bad offset?                 */
     signal invalid_time               /* go issue the error                */
   alarmtime = atime *1000             /* set alarmtime in milliseconds     */
   numdays = 0                         /* set date to current date          */
 end
 else do
   parse var atime intime ' ' indate   /* split into a date and time        */
   SIGNAL ON syntax NAME invalid_time  /* enable a syntax trap              */
                                       /* get input time in millisecs       */
   mtime = time('S', intime, 'N') * 1000
   ctime = time('S') * 1000            /* get current time in millisecs     */
   dtime = 24 * 60 * 60 * 1000         /* get 24 hrs in a day in millisecs  */
   dayDelta = 0                        /* default to no day adjustment      */
   if mtime < ctime then do            /* earlier time?                     */
     mtime = mtime + dtime             /* add in a day                      */
     dayDelta = -1                     /* and set an adjustment             */
   end

   numdays = 0                         /* set default number of days        */
   if indate \== '' then               /*  Is date specified?               */
                                       /* calculate number of days from     */
                                       /*current date                       */
     numdays = date('B',indate,'N') - date('B') + dayDelta
   signal off syntax                   /* no longer trapping syntax errors  */
   signal on syntax
   if numdays < 0 then                 /* was the date in the past?         */
     raise syntax 93.951 array (atime) /* Invalid alarmtime                 */
   alarmtime = mtime - ctime           /* set alarm relative to current time*/
 end

 guard off                             /* Allow other processess access     */
 reply                                 /* and go concurrent                 */

 self~!startTimer(numdays, alarmtime)  /* Call native method to start timer */
 eventSemHandle = 0                    /* cleared it to indicate (to cancel)*/
                                       /*  That the timer has expired.      */
 guard on                              /* get exclusive use of object       */

 if canceled = 0 then do               /* is the timer canceled?            */
   SIGNAL ON syntax NAME exception     /* enable syntax traps               */
   msgobj~send                         /* run the message                   */
 end
 exit

 invalid_time:
   signal on syntax
   raise syntax 93.951 array (atime)   /* Invalid alarmtime                 */

 exception:                            /* define exception handler          */
 syntax:
   raise propagate                     /* just propagate the error          */

::METHOD !startTimer PRIVATE unguarded EXTERNAL 'REXX alarm_startTimer'

 /**************************************************************************/
 /* Class  Alarm                                                           */
 /* Method CANCEL                                                          */
 /* Function                                                               */
 /*        To cancel a pending alarm request represented by the receiver.  */
 /*        This method taken no action if the timer has already expired.   */
 /* Input  none                                                            */
 /* Output Nothing                                                         */
 /**************************************************************************/

::METHOD cancel unguarded
 expose canceled eventSemHandle timerStarted

 use strict arg

 guard on  when timerStarted              /* Wait until timer is actually set  */
                                          /* if time hasn't expired?           */
 if eventSemHandle \= 0 then
   do
                                          /* cancel the timer.                 */
      canceled = 1
      self~!stopTimer(eventSemHandle)
   end
 return

::METHOD !stopTimer PRIVATE unguarded EXTERNAL 'REXX alarm_stopTimer'



/*
   name:    CircularQueue.rex
   author:  Rony G. Flatscher, Rick McGuire
   date:    2006-05-09, 2006-05-11, 2006-05-15, 2006-05-16, 2006-05-17, 2006-05-27
   purpose: allow to use a circular queue (buffer) of predefined size; if queue is full
            new entries overwrite existing ones in a circular fashion; also allows for
            resizing the circular queue at runtime
   license: CPL 1.0

   documentation:

   The CircularQueue class
   =======================

      This is a collection class which allows for storing objects in a circular queue
      of a predefined size. Once the end of the queue has been reached, new item
      objects are inserted from the beginning, replacing earlier entries.

      The collected objects can be processed in FIFO (first in, first out) or in a
      stack-like LIFO (last in, first out) order.



   OF (Class Method)
   =================

          +-,----+
          v      |
   >>-OF(---item-+-)--------------------------<<

   Returns a newly created CircularQueue object containing the specified item
   objects in the order specified. The number of listed items determines the
   size of the circular queue.


   INIT
   ====

   >>-INIT(size)----------------------------------<<

   Constructor method invoked by the NEW method, which determines the size of
   the circular queue.


   MAKEARRAY
   =========
                 +-Fifo-----+
   >>-MAKEARRAY(-+----------+-)----------------------<<
                 +-,-order--+

   Returns a single-index array containing the items of the circular queue in the
   specified order.

   The following orders can be used. (Only the capitalized letter is needed; all
   characters following it are ignored.)

   Fifo
      "first-in, first-out", default

   Lifo
      stacklike, "last-in, first-out"


   PUSH
   ====

   >>-PUSH(item)----------------------------------<<

   Makes the object item a member item of the circular queue, inserting the item
   object in front of the first item in the queue. The pushed item object will be
   the new first item in the circular queue.

   If the circular queue is full, than the last item stored in the circular queue
   will be deleted, before the insertion takes place. In this case the deleted item
   will be returned, otherwise .nil.



   QUEUE
   =====

   >>-QUEUE(item)---------------------------------<<

   Makes the object item a member item of the circular queue, inserting the item
   at the end of the circular queue.

   If the circular queue is full, than the first item will be deleted, before the
   insertion takes place. In this case the deleted item will be returned, otherwise .nil.



   RESIZE
   ======

                      +-Fifo-----+
   >>-RESIZE(-newSize-+----------+-)----------------------<<
                      +-,-order--+

   Resizes the circular queue object to be able to contain "newSize" items.
   If the previous size was larger than "newSize", than the now superfluous
   items are removed in the specified order.

   The following orders can be used. (Only the capitalized letter is needed; all
   characters following it are ignored.)

   Fifo
      "first-in, first-out", default: keeps the newest entries

   Lifo
      stacklike, "last-in, first-out": keeps the oldest entries

   Note: resizing with a value of "0" effectively removes all items from the
   circular queue.


   SIZE
   =====

   >>-SIZE----------------------------------------<<

   Returns the maximum number of objects that can be stored in the circular queue.



   SUPPLIER
   =========
                +-Fifo-----+
   >>-SUPPLIER(-+----------+-)----------------------<<
                +-,-order--+

   Returns a supplier object for the collection. After you have obtained a supplier,
   you can send it messages (see The Supplier Class) to enumerate all the items
   that were in the circular queue at the time of the supplier's creation.

   The supplier will enumerate the items in the specified order. (Only the capitalized
   letter is needed; all characters following it are ignored.)

   Fifo
      "first-in, first-out", default

   Lifo
      stacklike, "last-in, first-out"


   STRING
   ======
              +-----","---+  +-Fifo----+
   >>-STRING(-+-----------+--+---------+-)---------<<
              +-delimiter-+  +-,-order-+

   Returns a string object that concatenates the string values of the collected
   item objects, using the delimiter string to delimit them, in the specified order.

   If the delimiter string argument is omitted the comma character is used as the
   default delimiter string.

   The following orders can be used. (Only the capitalized letter is needed;
   all characters following it are ignored.)

   Fifo
      "first-in, first-out", default

   Lifo
      stacklike, "last-in, first-out"

   --------------- CircularQueue example --------------

      -- create a circular buffer with five items
   u=.circularQueue~of("a", "b", "c", "d", "e")
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say

   u~resize(4, "FIFO")     -- resize fifo-style (keep newest)
   say "after resizing to 4 items in FIFO style (keeping the newest):"
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say

   u~resize(2, "LILO")     -- resize lifo-style (keep oldest)
   say "after resizing to 2 items in LIFO style (keeping the oldest):"
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say

   u~resize(0)             -- resize lifo-style (keep oldest)
   say "after resizing to 0 items, thereby deleting all items:"
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say

   u~resize(2)             -- resize lifo-style (keep oldest)
   say "after resizing to 2, size="u~size "and items="u~items
   u~~queue('x')~~queue('y')~~queue('z')
   say "after queuing the three items 'x', 'y', 'z':"
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say

   u~~push('1')~~push('2')~~push('3')
   say "after pushing the three items '1', '2', '3':"
   say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
   say


/*
Output:

   content: [a,b,c,d,e], content (LIFO): [e->d->c->b->a]

   after resizing to 4 items in FIFO style (keeping the newest):
   content: [b,c,d,e], content (LIFO): [e->d->c->b]

   after resizing to 2 items in LIFO style (keeping the oldest):
   content: [b,c], content (LIFO): [c->b]

   after resizing to 0 items, thereby deleting all items:
   content: [], content (LIFO): []

   after resizing to 2, size=2 and items=0
   after queuing the three items 'x', 'y', 'z':
   content: [y,z], content (LIFO): [z->y]

   after pushing the three items '1', '2', '3':
   content: [3,2], content (LIFO): [2->3]

*/


*/

   -- circular buffer (round-robin queue) of a defined size
::class "CircularQueue" subclass queue public


::method of class

  storage=self~new(arg())     -- create a circular queue of appropriate size

  do i=1 to arg()
     storage~queue(arg(i))    -- place item object into the circular queue
  end
  return storage              -- return instance


::method init                 -- create an instance, memorizes the size
  expose size
  use strict arg size

  -- check for whole number >= 0, raise error
  if datatype(size, "Whole")=.false | size<0  then
     raise syntax 93.906 array ("size", size)

  self~init:super
  return


::METHOD size                 -- return size
  expose size
  use strict arg
  return size


::METHOD resize               -- allow to resize the circularQueue
  expose size

  use strict arg newSize, order = "F"

   -- check for whole number >= 0, raise error
   if datatype(newSize, "Whole")=.false | newSize<0  then
      raise syntax 93.906 array (1, arg(1))

   order = order~upper~left(1)

   if pos(order, "FL")=0 then  -- oops: not a valid argument!
      raise syntax 93.914 array (2, '"F" (FIFO) or "L" (LIFO)', arg(2))


   if newSize<size then       -- too many items, we need to remove the superfluous ones
   do
      removeNr=size-newSize   -- number of elements to remove

      if order="L" then       -- LIFO: remove the newest entries (keep the oldest)
         idx=self~items-removeNr+1    -- determine the index to which (includingly) the removes need to take place
      else                    -- FIFO: remove the oldest entries (keep the newest)
         idx=1                -- remove the first element(s)

      do removeNr             -- repeat removal
         self~remove(idx)     -- remove item
      end
   end
   size=newSize               -- remember new size
   return newSize             -- return the new size


::METHOD queue                -- put an element into the queue, possibly replacing an existing one
  expose size

  use strict arg item
  if size=0 then return .nil  -- size is 0, do not process!

  if self~items >= size then
     item=self~pull           -- if we've gone over the size, remove this
  else
     item=.nil                -- return value a .nil to indicate that we were not forced to remove an existing item

  forward class (super) continue -- allow the superclass to handle adding the item
  return item                 -- return pulled item

::METHOD push
  expose size
  use strict arg item

  if size=0 then return .nil  -- size is 0, do not process !

  if self~items >= size then
     item=self~remove(self~items)   -- remove the end item.
  else
     item=.nil                -- return value a .nil to indicate that we were not forced to remove an existing item

  forward class (super) continue    -- allow the superclass to handle adding the item
  return item                 -- return removed item


-----------------------------


::method makearray            -- return a supplier object
  expose size storage

  use strict arg order="F"

  order = order~upper~left(1)

  if pos(order, "FL")=0 then  -- oops: not a valid argument!
     raise syntax 93.914 array (1, '"F" (FIFO) or "L" (LIFO)', arg(1))

  if order="L" then           -- in LIFO (last-in, first-out) order (stack-like)
  do
     aCopy=self~copy          -- work on a copy (= snapshot)
     items=aCopy~items        -- get number of items
     valArr=.array~new(items)
     k=0
     do i=items to 1 by -1
        k=k+1
        valArr[k]=aCopy~at(i)
     end
     return valArr
  end
  else
  do
     arr=.array~new(0)
     FORWARD class (super) arguments (arr)-- forward to superclass, remove possible argument
     -- FORWARD class super array ()-- forward to superclass, remove possible argument
  end

::method supplier             -- return a supplier object
  expose size

  use strict arg order="F"

  order = order~upper~left(1)
  if pos(order, "FL")=0 then  -- oops: not a valid argument!
     raise syntax 93.914 array (1, '"F" (FIFO) or "L" (LIFO)', arg(1))

  if order="L" then           -- in LIFO (last-in, first-out) order (stack-like)
  do
     aCopy=self~copy          -- work on a copy (= snapshot)
     items=aCopy~items        -- get number of items
     valArr=.array~new(items) -- create value (item) array
     idxArr=.array~new(items) -- create index array
     k=0
     do i=items to 1 by -1    -- iterate through circular queue
        k=k+1
        valArr[k]=aCopy~at(i)
        idxArr[k]=i
     end
     return .supplier~new(valArr, idxArr)
  end
  else                        -- let the superclass create and return the supplier object
  do
     FORWARD class (super) array ()-- forward to superclass, remove possible argument
  end


::method string               -- create a string representation, using the optional delimiter
  expose size

  use strict arg delimiter=",", order = "F"

  order = order~upper~left(1)
  if self~items=0 then        -- return empty strings, if no elements
     return ""

  order = order~upper~left(1)
  if pos(order, "FL")=0 then  -- oops: not a valid argument!
     raise syntax 93.914 array (2, '"F" (FIFO) or "L" (LIFO)', arg(2))

  mb=.MutableBuffer~new       -- use a MutableBuffer for the string chunks
                              -- use MAKEARRAY for a snapshot in the desired order
  array=self~makearray(order) -- use supplied order

  k=.false                    -- append supplied delimiter?
  do i=1 to array~items
     if k then                -- at least one item already there, hence use delimiter
        mb~append(delimiter)
     else                     -- first iteration
        k=.true

     mb~append(array[i]~string) -- get element from array, get its string value
  end

  return mb~string            -- now turn MutableBuffer object into a plain string

::CLASS Properties subclass Directory public
::METHOD load class
  use arg input
  properties = .properties~new
  forward to (properties) continue
  return properties


::METHOD load
  use strict arg input
  if input~isInstanceOf(.string) then  -- if a string use it as a filename
  do
     stream=.stream~new(input)      -- create stream object
     self~load(stream)              -- load its properties
     stream~close                   -- close stream
     return
  end

  signal on notready

  do forever
     line = input~linein~strip('L')
     -- ignore comment lines
     if line == "" | line~substr(1, 2) == "--" then
         iterate
     parse var line name '=' value
     name = name~strip

     self~put(value, name)

  end
  -- hit EOF, just return
  notready:
  return

::METHOD save
  use strict arg output

  if output~isInstanceOf(.string) then  -- if a string use it as a filename
  do
     stream=.stream~new(output)     -- create stream object
     self~save(stream)              -- load its properties
     stream~close                   -- close stream
     return
  end

  supplier = self~supplier

  do while supplier~available
      name = supplier~index
      value = supplier~item

      output~lineout(name||"="||value)

      supplier~next
  end


::METHOD setProperty
  use strict arg name, value

  value = value~request('STRING')

  if .nil == value then do
     raise syntax 93.938 array (2)  -- raise an error
  end

  self~put:super(value, name)


::METHOD getProperty
  use strict arg name, default

  value = self~at(name)
  if .nil == value then do
      if arg(2, 'e') then
          value = default
  end

  return value

::METHOD setWhole
  args = arg(1, 'A')

  if \args~hasIndex(2) then
     raise syntax 93.903 array (2)  -- raise an error

  if \datatype(args[2], 'W') then
     raise syntax 93.905 array (2, args[2])  -- raise an error

  forward message 'SETPROPERTY'


::METHOD getWhole
  forward message 'GETPROPERTY' continue

  value = result
  if \datatype(value, 'W') then
     raise syntax 26.901 array (value)  -- raise an error

  return value


::METHOD setLogical
  args = arg(1, 'A')

  if \args~hasIndex(2) then
     raise syntax 93.903 array (2)  -- raise an error

  if \datatype(args[2], 'O') then
     raise syntax 34.901 array (2, args[2])  -- raise an error

  if args[2] then
     args[2] = "true"
  else
     args[2] = "false"

  forward message 'SETPROPERTY' arguments (args)


::METHOD getLogical
  forward message 'GETPROPERTY' continue

  value = result
  if value == '1' | value == 'true' then
      return .true
  else if value == '0' | value == 'false' then
      return .false
  raise syntax 34.904 array (value)  -- raise an error


::METHOD "[]="
  use strict arg value, name

  value = value~request('STRING')

  if .nil == value then do
     raise syntax 93.938 array (1)  -- raise an error
  end

  forward class (super) array (value, name)


::METHOD put
  use strict arg value, name

  value = value~request('STRING')

  if .nil == value then do
     raise syntax 93.938 array (1)  -- raise an error
  end

  forward class (super) array (value, name)

